package com.ailk.openbilling.persistence.sys.entity;

import javax.persistence.Table;
import jef.database.DataObject;
import javax.persistence.Id;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import org.apache.commons.lang.ObjectUtils;
import org.apache.commons.lang.builder.HashCodeBuilder;
import jef.codegen.support.NotModified;
/**
 * This class was generated by EasyFrame according to the table in database.
 * You need to modify the type of primary key field, to the strategy your own.
 * 
 */
@NotModified
@Entity
@Table(schema="sd",name="SYS_CYCLE_PATTERN_TRANSFER")
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(propOrder={"patternId","stsFrom","osStsFrom","stsTo","osStsTo","policyId","bNotificationCode","aNotificationCode","validDays","triggerEventType","fireEventType"})
public class SysCyclePatternTransfer extends DataObject{


	/**
	 * Pattern ID
	 */
	@Id
	@Column(name="PATTERN_ID",precision=8,columnDefinition="NUMBER",nullable=false)
	@XmlElement(name="patternId")
	private Integer patternId;

	/**
	 * State from
	 */
	@Id
	@Column(name="STS_FROM",precision=8,columnDefinition="NUMBER",nullable=false)
	@XmlElement(name="stsFrom")
	private Integer stsFrom;

	/**
	 * 10:normal
11:outgoing call barring
12:call barring
	 */
	@Id
	@Column(name="OS_STS_FROM",precision=8,columnDefinition="NUMBER",nullable=false)
	@XmlElement(name="osStsFrom")
	private Integer osStsFrom;

	/**
	 * State to
	 */
	@Id
	@Column(name="STS_TO",precision=8,columnDefinition="NUMBER",nullable=false)
	@XmlElement(name="stsTo")
	private Integer stsTo;

	/**
	 * 10:normal
11:outgoing call barring
12:call barring
	 */
	@Id
	@Column(name="OS_STS_TO",precision=8,columnDefinition="NUMBER",nullable=false)
	@XmlElement(name="osStsTo")
	private Integer osStsTo;

	/**
	 * Policy identifier: when value=0, it refers to always true.
	 */
	@Column(name="POLICY_ID",precision=8,columnDefinition="NUMBER")
	@XmlElement(name="policyId")
	private Integer policyId;

	/**
	 * Notification rule before changing:
Not send SMS to customer if null.
	 */
	@Column(name="B_NOTIFICATION_CODE",precision=8,columnDefinition="NUMBER",nullable=false)
	@XmlElement(name="bNotificationCode")
	private Integer bNotificationCode;

	/**
	 * Notification rule after changing:
Not send SMS to customer if null.
	 */
	@Column(name="A_NOTIFICATION_CODE",precision=8,columnDefinition="NUMBER",nullable=false)
	@XmlElement(name="aNotificationCode")
	private Integer aNotificationCode;

	/**
	 * Effective days of new state:
When value=0, it is not necessary to modify previous date.
For example,If one customer gets a disount on his/her birthday which will not invlove in recurring table's date.
	 */
	@Column(name="VALID_DAYS",precision=8,columnDefinition="NUMBER",nullable=false)
	@XmlElement(name="validDays")
	private Integer validDays;

	/**
	 * Used to define the life cycle change which is triggered by system time, take no_validity as an example, it will change from active to suspend-novalidity.

1: CRM_Request, including most cycle life change of postpaid subscriber, from webservice interface of lifecyclemgnt.
2: Balance_Change, from top-up/usage-rating, etc. In domestic, it will trigger suspending if there’s no sufficient balance. But AIS requests that it won’t suspend if there’s no sufficient balance, without any action. If the balance is greater than 0 after balance change, it can trigger service connection of prepaid subscriber.
3: Account_Validity_Change, AIS requests that it will trigger the action of suspending when account book becomes invalid. IMS will scan the valid date, and automatically notify the life cycle module to suspend once it becomes invalid. Valid date prolonging and balance change generally occur in the same time, and the accounting module should affirm that which event to be triggered, or both.
4: State_Expire, after subscriber coming into a state of suspending, it may come into a state of disable after a period of time, and expiration event triggered this life cycle change. IMS will scan subscriber state table, and will automatically trigger StateExpire event when life cycle becomes expired, and notify life cycle module to modify subscriber state.
5: Disable, when subscriber comes into a state of Disable, it will notify accounting module to conduct a series of operations such as balance clearance, and these operations are triggered by this event.
Two detailed triggering modes are as follows:
1. throw the event to cloud platform, and accounting module will register at the cloud platform to process this event;
2. By policy configuration, and call policy directly when event occurs.
	 */
	@Id
	@Column(name="TRIGGER_EVENT_TYPE",precision=8,columnDefinition="NUMBER",nullable=false)
	@XmlElement(name="triggerEventType")
	private Integer triggerEventType;

	@Column(name="FIRE_EVENT_TYPE",columnDefinition="Varchar",length=5)
	@XmlElement(name="fireEventType")
	private String fireEventType;

	public void setPatternId(Integer obj){
		this.patternId = obj;
	}

	public Integer getPatternId(){
		return patternId;
	}

	public void setStsFrom(Integer obj){
		this.stsFrom = obj;
	}

	public Integer getStsFrom(){
		return stsFrom;
	}

	public void setOsStsFrom(Integer obj){
		this.osStsFrom = obj;
	}

	public Integer getOsStsFrom(){
		return osStsFrom;
	}

	public void setStsTo(Integer obj){
		this.stsTo = obj;
	}

	public Integer getStsTo(){
		return stsTo;
	}

	public void setOsStsTo(Integer obj){
		this.osStsTo = obj;
	}

	public Integer getOsStsTo(){
		return osStsTo;
	}

	public void setPolicyId(Integer obj){
		this.policyId = obj;
	}

	public Integer getPolicyId(){
		return policyId;
	}

	public void setBNotificationCode(Integer obj){
		this.bNotificationCode = obj;
	}

	public Integer getBNotificationCode(){
		return bNotificationCode;
	}

	public void setANotificationCode(Integer obj){
		this.aNotificationCode = obj;
	}

	public Integer getANotificationCode(){
		return aNotificationCode;
	}

	public void setValidDays(Integer obj){
		this.validDays = obj;
	}

	public Integer getValidDays(){
		return validDays;
	}

	public void setTriggerEventType(Integer obj){
		this.triggerEventType = obj;
	}

	public Integer getTriggerEventType(){
		return triggerEventType;
	}

	public void setFireEventType(String obj){
		this.fireEventType = obj;
	}

	public String getFireEventType(){
		return fireEventType;
	}

	public SysCyclePatternTransfer(){
	}

	public SysCyclePatternTransfer(Integer patternId,Integer stsFrom,Integer osStsFrom,Integer stsTo,Integer osStsTo,Integer triggerEventType){
		this.patternId = patternId;
		this.stsFrom = stsFrom;
		this.osStsFrom = osStsFrom;
		this.stsTo = stsTo;
		this.osStsTo = osStsTo;
		this.triggerEventType = triggerEventType;
	}

	public boolean equals(final Object rhs0){
		if (rhs0 == null)return false;
		SysCyclePatternTransfer rhs=(SysCyclePatternTransfer)rhs0;
		if(!ObjectUtils.equals(stsFrom, rhs.stsFrom)) return false;
		if(!ObjectUtils.equals(patternId, rhs.patternId)) return false;
		if(!ObjectUtils.equals(stsTo, rhs.stsTo)) return false;
		if(!ObjectUtils.equals(osStsTo, rhs.osStsTo)) return false;
		if(!ObjectUtils.equals(triggerEventType, rhs.triggerEventType)) return false;
		if(!ObjectUtils.equals(osStsFrom, rhs.osStsFrom)) return false;
		return super.isEquals(rhs);
	}

	public int hashCode(){
		return new HashCodeBuilder()
		.append(stsFrom)
		.append(patternId)
		.append(stsTo)
		.append(osStsTo)
		.append(triggerEventType)
		.append(osStsFrom)
		.append(super.getHashCode())
		.toHashCode();
	}


public enum Field implements jef.database.Field{patternId,stsFrom,osStsFrom,stsTo,osStsTo,policyId,bNotificationCode,aNotificationCode,validDays,triggerEventType,fireEventType}
}